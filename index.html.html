<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Hand Tracking Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            opacity: 0.8;
        }
        #input_video { width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background: rgba(0, 255, 204, 0.1);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        button:hover { background: #00ffcc; color: #000; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 24px;
            z-index: 100;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing from Bhautik </div>

    <div id="ui">
        <h2>Interactive Particle System</h2>
        <p>üñê <b>Move Hand</b>: Control flow</p>
        <p>üëå <b>Pinch</b>: Attract / Collapse</p>
        <p>‚Üî <b>Horizontal Position</b>: Change Color</p>
    </div>

    <div class="controls">
        <button onclick="setShape('sphere')">1. Sphere</button>
        <button onclick="setShape('heart')">2. Heart</button>
        <button onclick="setShape('flower')">3. Flower</button>
        <button onclick="setShape('saturn')">4. Saturn</button>
        <button onclick="setShape('spiral')">5. Galaxy</button>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.15;
    
    // Global State
    let targetShape = 'sphere';
    let isPinching = false;
    let handPosition = new THREE.Vector3(0, 0, 0);
    let hueOffset = 0.0;
    
    // Arrays for morphing
    const particlesData = []; // Stores current positions and velocities
    const shapePositions = {
        sphere: [],
        heart: [],
        flower: [],
        saturn: [],
        spiral: []
    };

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize Particles
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Initial random positions
        positions[i * 3] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

        colors[i * 3] = 1;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;

        particlesData.push({
            velocity: new THREE.Vector3(),
            currentPos: new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2])
        });
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: createCircleTexture()
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- SHAPE GENERATORS ---
    function generateShapes() {
        // 1. SPHERE
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = 10;
            const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
            const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
            shapePositions.sphere.push(
                r * Math.cos(theta) * Math.sin(phi),
                r * Math.sin(theta) * Math.sin(phi),
                r * Math.cos(phi)
            );
        }

        // 2. HEART
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            // Parametric heart formula
            const x = 16 * Math.pow(Math.sin(theta), 3) * Math.sin(phi);
            const y = (13 * Math.cos(theta) - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta));
            const z = 16 * Math.pow(Math.sin(theta), 3) * Math.cos(phi);
            const scale = 0.5;
            shapePositions.heart.push(x * scale, y * scale, z * scale);
        }

        // 3. FLOWER
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const r = 5 + 3 * Math.cos(5 * u) * Math.sin(5 * v); // Petal modulation
            shapePositions.flower.push(
                r * Math.sin(v) * Math.cos(u),
                r * Math.sin(v) * Math.sin(u),
                r * Math.cos(v)
            );
        }

        // 4. SATURN
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 70% Planet, 30% Rings
            if (i < PARTICLE_COUNT * 0.7) {
                // Sphere
                const r = 6;
                const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT*0.7));
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                shapePositions.saturn.push(
                    r * Math.cos(theta) * Math.sin(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(phi)
                );
            } else {
                // Rings
                const angle = Math.random() * Math.PI * 2;
                const radius = 9 + Math.random() * 6;
                shapePositions.saturn.push(
                    Math.cos(angle) * radius,
                    (Math.random()-0.5) * 0.5, // Flattened Y
                    Math.sin(angle) * radius
                );
            }
        }

        // 5. SPIRAL GALAXY
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const angle = i * 0.05;
            const r = i * 0.002;
            shapePositions.spiral.push(
                r * 15 * Math.cos(angle),
                (Math.random() - 0.5) * 5,
                r * 15 * Math.sin(angle)
            );
        }
    }
    generateShapes();

    function setShape(name) {
        targetShape = name;
    }

    // Helper: Texture for soft particles
    function createCircleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;
        
        // Morphing and Physics
        const targetArr = shapePositions[targetShape];
        const colorObj = new THREE.Color();
        
        // Dynamic hue based on hand X position (mapped 0 to 1)
        const baseHue = hueOffset;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const px = positionsAttribute.getX(i);
            const py = positionsAttribute.getY(i);
            const pz = positionsAttribute.getZ(i);

            // 1. Get Target Position for current shape
            const tx = targetArr[i * 3];
            const ty = targetArr[i * 3 + 1];
            const tz = targetArr[i * 3 + 2];

            // 2. Physics: Move towards target
            // Lerp factor
            let lerpSpeed = 0.03;
            
            let vx = (tx - px) * lerpSpeed;
            let vy = (ty - py) * lerpSpeed;
            let vz = (tz - pz) * lerpSpeed;

            // 3. Hand Interaction
            // Calculate distance from particle to hand
            const dx = px - handPosition.x;
            const dy = py - handPosition.y;
            const dz = pz - handPosition.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

            if (dist < 15) {
                if (isPinching) {
                    // ATTRACT (Black Hole)
                    const force = 2.0 / (dist + 0.1);
                    vx -= dx * force;
                    vy -= dy * force;
                    vz -= dz * force;
                } else {
                    // REPEL / SWIRL
                    const force = 1.0 / (dist + 0.1);
                    // Add a little curl noise/cross product for swirl
                    vx += (dx * force) + (dy * 0.5); 
                    vy += (dy * force) - (dx * 0.5);
                    vz += (dz * force);
                }
            }

            // Update positions
            positionsAttribute.setXYZ(i, px + vx, py + vy, pz + vz);

            // 4. Color Update
            // Vary color slightly per particle + global hand hue
            colorObj.setHSL((baseHue + (i / PARTICLE_COUNT) * 0.2) % 1.0, 0.8, 0.6);
            colorsAttribute.setXYZ(i, colorObj.r, colorObj.g, colorObj.b);
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;
        
        // Gentle scene rotation
        particleSystem.rotation.y += 0.001;

        renderer.render(scene, camera);
    }

    animate();

    // --- MEDIAPIPE HAND TRACKING ---
    const videoElement = document.getElementById('input_video');
    
    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Track Index Finger Tip (Landmark 8)
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            // Map video coordinates (0-1) to 3D world coordinates (-30 to 30 approx)
            // Note: Camera is mirrored via CSS, so we invert X logic appropriately
            const x = (0.5 - indexTip.x) * 40; 
            const y = (0.5 - indexTip.y) * 30;
            // Simple depth approximation using landmark size or just fixed
            const z = 0; 

            // Smooth hand movement
            handPosition.lerp(new THREE.Vector3(x, y, z), 0.1);

            // 2. Detect Pinch (Distance between Index and Thumb)
            const pinchDist = Math.sqrt(
                Math.pow(indexTip.x - thumbTip.x, 2) +
                Math.pow(indexTip.y - thumbTip.y, 2)
            );

            isPinching = pinchDist < 0.05; // Threshold for pinch

            // 3. Map X position to Color Hue
            hueOffset = indexTip.x; // 0.0 to 1.0
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    cameraUtils.start();

    // --- WINDOW RESIZE ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>